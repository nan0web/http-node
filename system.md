# Системна інструкція `@nan0web/http-node`

## Мета пакету

Пакет `@nan0web/http-node` призначений для забезпечення легковагової, тестованої та мінімалістичної HTTP-самостійної реалізації (клієнт та сервер) для Node.js середовища. Основні задачі пакету:

1. Надання функціоналу для створення HTTP-серверів з підтримкою роутингу
2. Реалізація Fetch API-сумісного клієнта з підтримкою HTTP/2
3. Забезпечення чистого та стабільного типізованого JavaScript-коду без надмірних залежностей
4. Робота в рамках філософії monorepo з високим покриттям тестами

## Основні принципи

Пакет створений з дотриманням таких ключових принципів:

### Мінімалізм та автономність
- Використання лише нативних модулів Node.js
- Нуль зовнішніх залежностей (крім однозначно необхідних)
- Відсутність конфігураційних файлів (окрім package.json)
- Спрощення API до максимально необхідного

### Тестування
- Покриття коду тестами понад 90%
- Тест-драйвен розробка (TDD)
- Тести написані на стандартному `node:test`
- Тести спрощені і зосереджені на критичних шляхах виконання

### Типізація
- Використання JSDoc для документування коду
- Статична типізація через `.d.ts` файли
- Забезпечення автодоповнення в редакторах коду
- Відсутність Typescript у продуктивному коді (лише для генерації `.d.ts`)

### Сумісність
- API, сумісне з веб-стандартами (Fetch API)
- Повна сумісність з нативним Node.js HTTP API
- Підтримка HTTP/1.1 та HTTP/2
- Обробка помилок статусу на основі RFC стандартів

## Архітектура

### Загальна структура
```
├── src
│   ├── client       - Клієнтська частина (fetch API)
│   ├── messages     - Сповіщення (request/response)
│   ├── middlewares  - Готові middleware компоненти
│   ├── server       - Серверна частина
│   └── test         - Тестові утиліти
```

### Логіка роботи клієнта

Клієнтська частина реалізує Fetch API сумісні методи:

1. Нижній рівень використовує нативні модулі `node:http`, `node:https` та `node:http2`
2. Використовує `ResponseMessage` як сумісний з Fetch API об'єкт відповіді
3. Реалізує таймаути запитів через AbortController
4. Має підтримку різних типів відповідей (json, binary, sockets)

Коли викликається `fetch(url, options)`:
- Формується правильний запит на основі опцій
- Створюється об'єкт AbortController для керування таймаутами
- Запитується HTTP/2 при використанні HTTPS та спеціальних опцій
- Відповідь оборочується в `ResponseMessage` для сумісності з Fetch API

### Логіка роботи сервера

Серверна частина побудована на:

1. Нативному `node:http` та `node:https` API
2. Власній реалізації роутеру з підтримкою параметрів у шляху
3. Middleware-системі для обробки запитів
4. Перевизначеннях `IncomingMessage` та `ServerResponse` для розширення функціоналу

Коли створюється і запускається сервер через `createServer()`:
- При вхідному запиті формується `IncomingMessage` з додатковими параметрами
- Запускається послідовне виконання middleware
- Роутер виконує відповідний обробник для шляху та методу
- Сервер реагує на DELETE-запити специфічними статусами за RFC

Express-js сумісні middleware і routing.

## Ключові компоненти

### 1. Роутер (`Router`)

- Клас `Router` обробляє шляхи з підтримкою параметрів (`/user/:id`)
- Підтримка усіх HTTP методів (GET, POST, PUT, DELETE тощо)
- Спеціальна обробка DELETE, HEAD і OPTIONS запитів
- Можливість використовувати окремо від серверу

### 2. Middleware система

Два основні middleware, що йдуть "з коробки":

- **bodyParser**: Автоматично парсить тіла запитів JSON та URL-encoded форматів
- **bruteForce**: Захист від брутфорсу за IP з таймінгом

Система дозволяє легке створення власних middleware:
```js
server.use((req, res, next) => {
  req.customProperty = "value"
  await next()
})
```

### 3. Повідомлення (`messages`)

- **IncomingMessage**: Розширений об'єкт запиту з додатковими властивостями
- **ResponseMessage**: Об'єкт відповіді сумісний з веб Fetch API
- **ServerResponse**: Розширена версія нативного ServerResponse з додатковим API

### 4. Клієнтський API

- `fetch()`: Найнижчий рівень клієнтського запиту
- `get()`, `post()`, `put()`, `patch()`, `del()`, `head()`, `options()`: Методи для швидкого створення запитів
- `APIRequest`: Високорівневий клас для створення API-клієнтів зі спільним base URL

## Обробка помилок

1. Таймаути запитів генерують `AbortError`
2. Помилки мережі генеруються нативними Node.js помилками
3. Помилки сервера обробляються внутрішнім механізмом з кодом 500
4. DELETE запити автоматично отримують статус 204 "No Content"
5. Відсутні шляхи повертають статус 404

## Тестування

Тестовий фреймворк використовує:

- Нативний `node:test` без додаткових залежностей
- Прості тестові сценарії з фокусом на критичних шляхах
- Мок-сервер для імітації запитів (`TestServer`)
- Мок-функція `mockFetch` для клієнтських тестів
- Автоматична генерація документації з тестів (як в `src/README.md.js`)

Покриття тестами в пакеті має бути не нижче 90%, що гарантує стабільність і надійність.

## Інтеграція з monorepo

Пакет `@nan0web/http-node` є частиною більшої системи, тому:

- Використовує спільні стандарти кодування
- Використовує спільні типи (`@nan0web/http`)
- Має спільні процедури тестування та покриття
- Є сумісним з іншими пакетами в monorepo
- Слідує загальній філософії розробки "zero dependencies"

## Оптимізації

- Зменшення кількості асинхронних операцій
- Використання нативного Node.js API без прокладок
- Спрощений роутинг без надлишкових регулярних виразів
- Мінімізація створення тимчасових об'єктів
- Обробка DELETE запитів на рівні створення відповіді

## Керування версіями

Пакет дотримується семантичного версіонування (SemVer):

- **Major зміни**: Зміни в API, що порушують сумісність
- **Minor зміни**: Додавання нових функцій без порушення сумісності
- **Patch зміни**: Виправлення помилок та невеликі поліпшення

Зміни завжди повинні супроводжуватися відповідними тестами та оновленою документацією.

## Розширення можливостей

Пакет може бути розширений через:

- Додавання власних middleware
- Роутинг з параметрами шляху
- Обробка спеціальних кейсів через класи повідомлень
- Додавання клієнтських методів через `APIRequest`

Однак, всі розширення повинні відповідати принципам мінімалізму та тестованості.

## Приклади написання тестів

Для тестування рекомендується дотримуватися таких правил:

1. Тест повинен мати чіткий сценарій що "він перевіряє"
2. Тест повинен мати однозначний результат (pass/fail)
3. Тести повинні бути самодостатніми (без зовнішніх залежностей)
4. Тест повинен мати мінімальну кількість асертів

Приклад тесту:
```js
it("should fetch JSON data successfully", async () => {
  // Arrange
  const server = createServer()
  server.get("/data", (req, res) => {
    res.json({ message: "ok" })
  })
  await server.listen()
  
  // Act
  const response = await fetch(`http://localhost:${server.port}/data`)
  const data = await response.json()
  
  // Assert
  assert.strictEqual(response.status, 200)
  assert.deepStrictEqual(data, { message: "ok" })
  
  // Cleanup
  await server.close()
})
```

Ці принципи забезпечують, що код залишається чистим, тестованим та простим у підтримці.
